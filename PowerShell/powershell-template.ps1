<#
.SYNOPSIS
  <Overview of script>

.DESCRIPTION
  <Brief description of script>

.PARAMETER -SampleParam
  <This parameter text will not be shown, since -SampleParam is not a real parameter listed in Param(). However, if a .PARAMETER help line is present and there is no Param(), all help text will fail.>

.PARAMETER LaunchedInCmd
  Used to indicate to this script when it has been launched in a Command Prompt windows (CMD.EXE)
  
  Formats output to the size of a standard Command Prompt (79 characters wide + 1) or to the size of a standard PowerShell window (119 characters winde + 1)

.PARAMETER LoadFunctions
  Use this switch to only load the functions in this script. The script main body execution will not run.

.INPUTS
  <Inputs if any, otherwise state None>

.OUTPUTS 
Log File
  The script log file stored in C:\Windows\Temp\<name>.log

.NOTES
  Version:        1.0
  Author:         <Name>
  Creation Date:  <Date>
  Purpose/Change: Initial script development

  Requires PSLogging module from 
  https://9to5it.com/powershell-logging-v2-easily-create-log-files/
  PowerShell Gallery:
  https://www.powershellgallery.com/packages/PSLogging/
  GitHub:
  https://www.powershellgallery.com/packages/PSLogging/

  AUTOGENERATED CONTENT
    The name, syntax, parameter list, parameter attribute table, common
    parameters, and remarks are automatically generated by the Get-Help cmdlet.

.EXAMPLE
  <Example explanation goes here>
  
  <Example goes here. Repeat this attribute for more than one example>

.LINK
about_Comment_Based_Help

.LINK
about_Requires

.LINK
about_Scripts

.LINK
https://ss64.com/ps/syntax-run.html

.LINK
https://ss64.com/ps/call.html

.LINK
about_Functions_CmdletBindingAttribute

.LINK
https://devblogs.microsoft.com/scripting/weekend-scripter-welcome-to-the-powershell-information-stream/
#>

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------#Requires-------------------------------------------------------

#Requires -Modules PSLogging
<#
# "#Requires" - You can use a #Requires statement to prevent a script from running without specified modules or snap-ins and a specified version of PowerShell. For more information, see about_Requires.
# help about_Requires
# help about_PSSnapins
# e.g. "#Requires -Version 6" "#Requires -RunAsAdministrator"
#>

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#1. PSLogging module
<#
# To insatll PSLogging module:
# https://docs.microsoft.com/en-us/powershell/developer/module/installing-a-powershell-module
# PowerShell v4:
# 	1. Find PSModulePath environment variable
# 		$Env:PSModulePath
# 		[Environment]::GetEnvironmentVariable("PSModulePath")
#	2. Find the PSLogging module
# 		.\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging
# 	3. Either copy the module to a location within the PSModulePath environment variable, or add the location of the module to the PSModulePath environment variable.
# 		3a. Copy the module to the location:
# 			# Install for Current User - $Home\Documents\WindowsPowerShell\Modules (%UserProfile%\Documents\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Home\Documents\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 			# Install for All Users - $Env:ProgramFiles\WindowsPowerShell\Modules (%ProgramFiles%\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Env:ProgramFiles\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 		3b. Add the module's path to the PSModulePath environment variable
# 			$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 			$p = [Environment]::GetEnvironmentVariable("PSModulePath")
# 			$p += ";$newModule"
# 			[Environment]::SetEnvironmentVariable("PSModulePath",$p)
# PowerShell v5: (and above)
# 	Find-Module -Name "PSLogging*" | Install-Module -Scope AllUsers 
# Accepted values: CurrentUser, AllUsers
# 	Update-Module PSLogging -Force
#>

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Header]--------------------------------------------------------

# Index:
# 1. <# .HELP #>
# 2. #Requires
# 3. [Header]
# 4. [Script Parameters]
# 5. [Initializations]
# 6. [Modules]
# 7. [Declarations]
# 8. [Functions]
# 9. [Execution]
# 10. [Footer]

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Run this script:
<#
# Tested with PowerShell versions:
# 5.1
# Get PowerShell version:
# $PSVersionTable.PSVersion

# To run from PowerShell command line:
# https://ss64.com/ps/syntax-run.html
# https://ss64.com/ps/syntax-scriptblock.html
# When passing a variable to a scriptblock it is important to consider the variable scope.
#    Each time the scriptblock is run; it will dynamically read the current value of the variable.
#    When a scriptblock is run using the "." (dot) operator, updates to a variable apply to the current scope.
#    When a scriptblock is run using the "&" (call) operator, updates to a variable are not reflected in the parent scope.
# help about_Scripts
# %USERPROFILE% = $env:UserProfile = $Home
# 'Dot-sourcing:'
# . "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1"
# . "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1" -Verbose -Debug
# . "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1" -Verbose -Debug -LaunchedInCmd
# . "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1" -LoadFunctions
# https://ss64.com/ps/source.html
# Using the 'call' operator (&):
# & "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1"
# & "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1" -Verbose -Debug
# & "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1" -Verbose -Debug -LaunchedInCmd
# https://ss64.com/ps/call.html

# To run help:
# Get-Help "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1"
# Get-Help "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\powershell-template.ps1" -Full
# Example help file:
# Get-Help Get-ChildItem
# Get-Help Get-ChildItem -Full

# Execution Policy:
# $oldExecutionPolicy = Get-ExecutionPolicy
# Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
# Set-ExecutionPolicy -ExecutionPolicy Bypass
# Set-ExecutionPolicy $oldExecutionPolicy
#>

#-----------------------------------------------------------------------------------------------------------------------
#--------------------------------------------------[Script Parameters]--------------------------------------------------

# Debugging: absolutely NO commands can come before Param (except for [CmdletBinding()] )
# Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
# https://ss64.com/ps/syntax-args.html

#http://techgenix.com/powershell-functions-common-parameters/
# To enable common parameters in functions (-Verbose, -Debug, etc.) the following 2 lines must be present:
#[CmdletBinding()]
#Param()
	
[CmdletBinding()]
#[CmdletBinding(SupportsShouldProcess=$true)]

#Script parameters go here
Param (
  #Script parameters go here
  # Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
  # help about_Functions_Advanced_Parameters
  # https://ss64.com/ps/syntax-args.html
  # https://ss64.com/ps/syntax-automatic-variables.html

  [Parameter(Mandatory=$false)]
  [switch]$LaunchedInCmd = $false,

  [Parameter(Mandatory=$false)]
  [switch]$LoadFunctions = $false
)

#-----------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------[Initializations]---------------------------------------------------

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Skip [Initializations] script block if -LoadFunctions is on.
If (-Not $LoadFunctions) {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Script name (including extension)
$ScriptName = $MyInvocation.MyCommand.Name
Write-Verbose "Script name: `"$ScriptName`""
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script dir (home directory of script)
Write-Verbose "Script home directory:"
#https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
$ScriptDir = Split-Path $script:MyInvocation.MyCommand.Path
Write-Verbose "$ScriptDir"
$ScriptDir = Split-Path -parent $MyInvocation.MyCommand.Definition # PoSh v2 compatible - thanks to https://stackoverflow.com/questions/5466329/whats-the-best-way-to-determine-the-location-of-the-current-powershell-script
Write-Verbose "$ScriptDir"
$ScriptDir = $PSScriptRoot # PoSh v3 compatible - This is an automatic variable set to the current file's/module's directory
Write-Verbose "$ScriptDir"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script path (full file path & name & extension of currently running script)
$ScriptPath = $MyInvocation.MyCommand.Path
Write-Verbose "Script full path:"
Write-Verbose "$ScriptPath"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Check if script is being Run as Administrator or not
$SessionIsAdminElevated = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
Write-Verbose "Session is running as Admin: $SessionIsAdminElevated"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'
#Set Error Action to Continue
$ErrorActionPreference = 'Continue'

#Set Verbose message display
#$VerbosePreference = "SilentlyContinue" # Will suppress Write-Verbose messages. This is the default value.
#$VerbosePreference = "Continue" # Will print out Write-Verbose messages. Gets set when -Verbose switch is used to run the script. (Or when you set the variable manually.)

#Set Debug message display
# help about_Debuggers
#$DebugPreference = "SilentlyContinue"
#$DebugPreference = "Continue"

#Set Progress Bar display
#* If the progress bar does not appear, check the value of the $ProgressPreference variable. If the value is set to SilentlyContinue, the progress bar is not displayed. For more information about Windows PowerShell preferences, see about_Preference_Variables.
#$ProgressPreference = "SilentlyContinue"
#$ProgressPreference = "Continue"

#Set Informational message display
#$InformationPreference = "SilentlyContinue"
#$InformationPreference = "Continue"

#Check Execution Policy
$RecommendedExecutionPolicy = "RemoteSigned"
Write-Verbose "Recommended Execution Policy = $RecommendedExecutionPolicy"
#Write-Host "Current Execution Policy =" (Get-ExecutionPolicy)
$startExecutionPolicy = Get-ExecutionPolicy
Write-Verbose "Current Execution Policy = $startExecutionPolicy"

#Check PowerShell version
$MinimumRequiredVersion = 6
# https://ss64.com/ps/get-host.html
# https://stackoverflow.com/questions/1825585/determine-installed-powershell-version
$PoShVersion = $PSVersionTable.PSVersion
Write-Verbose "Minimum required PowerShell version = $MinimumRequiredVersion"
Write-Verbose "Current PowerShell version = $($PSVersionTable.PSVersion.Major).$($PSVersionTable.PSVersion.Minor)"
# https://ss64.com/ps/if.html
IF ($PSVersionTable.PSVersion.Major -lt $MinimumRequiredVersion) {
	Write-Warning "This script requires at least PowerShell version $MinimumRequiredVersion. Running version $PoShVersion"
	Write-Debug "This script requires at least PowerShell version $MinimumRequiredVersion. Running version $PoShVersion"
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}
# Skip [Initializations] script block if -LoadFunctions is on.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Modules]-------------------------------------------------------

#Import Modules
Write-Verbose "Importing modules..."
Write-Verbose `n # New line (carriage return and newline, `r`n)

Import-Module PSLogging

#Import-Module UserTimeFunctions
Import-Module "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\modules\TimeFunctions\TimeFunctions.psm1"

Write-Verbose `r`n
Write-Verbose "Module import complete..."
Write-Verbose `r`n

#Dot-Source external functions
Write-Verbose "Dot Sourcing external functions..."
Write-Verbose `r`n

#. "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\modules\TimeFunctions\TimeFunctions.psm1"

Write-Verbose `r`n
Write-Verbose "Dot Sourcing complete..."

#-----------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------[Declarations]----------------------------------------------------

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Skip [Declarations] script block if -LoadFunctions is on.
If (-Not $LoadFunctions) {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#Script Version
$sScriptVersion = '1.0'

#Log File Info
$sLogPath = $ScriptDir
$yesterday = [DateTime]::Today.AddDays(-1)
$TodaysDate = Get-Date -Format FileDate
Write-Verbose "Date code = $TodaysDate"
$sLogName = $MyInvocation.MyCommand.Name.Substring(0,$MyInvocation.MyCommand.Name.Length-4) + "_" + $TodaysDate + ".log"
Write-Verbose "LogName = $sLogName"
$sLogFile = Join-Path -Path $sLogPath -ChildPath $sLogName
Write-Verbose "LogFile = $sLogFile"

# Create Log file if we don't have one already
If (!($sLogPath)) { Start-Log -LogPath $sLogPath -LogName $sLogName -ScriptVersion $sScriptVersion }

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}
# Skip [Declarations] script block if -LoadFunctions is on.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Functions]------------------------------------------------------

# help about_Functions
# help about_Functions_Advanced
# help about_Functions_Advanced_Methods
# help about_Functions_Advanced_Parameters
# Get-Verb

#Index of functions:
#  1. Show-ExampleFunctionTemplate (Example Function)
#  2. Start-PSAdmin
#  3. Test-IsAdmin
#  4. Get-FunctionName
#  5. Get-ScriptPath
#  6. Get-ScriptDirectory
#  7. Get-ScriptDirectory2
#  8. Get-ScriptDirectory3
#  9. Write-HorizontalRule
# 10. Write-HorizontalRuleAdv (Aliases: "Write-HR")
# 11. PromptForChoice-YesNoSectionSkip
# 12. PromptForChoice-YesNo

#-----------------------------------------------------------------------------------------------------------------------
Function Show-ExampleFunctionTemplate { #-------------------------------------------------------------------------------
	<#
	.SYNOPSIS
	Short explanation of what this function does.
	
	.DESCRIPTION
	Longer, more descriptive definition of what this function's purpose is, what it was designed to do.
	
	.NOTES
	Generally, the 3 help topics .SYNOPSIS, .DESCRIPTION, and .NOTES are the bare minimum required for Comment-Based Help to work, but this is inconsistent across PowerShell versions.
	
	.LINK
	help about_Comment_Based_Help
	http://techgenix.com/powershell-functions-common-parameters/
	help about_Requires
	help about_CommonParameters
	#>
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#Requires -Modules PSLogging
	<#
	# "#Requires" - You can use a #Requires statement to prevent a script from running without specified modules or snap-ins and a specified version of PowerShell. For more information, see about_Requires.
	# e.g. "#Requires -Version 6" "#Requires -RunAsAdministrator"
	#>
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#http://techgenix.com/powershell-functions-common-parameters/
	# To enable common parameters in functions (-Verbose, -Debug, etc.) the following 2 lines must be present:
	#[CmdletBinding()]
	#Param()
	
	[CmdletBinding()]
	#[CmdletBinding(SupportsShouldProcess=$true)]
	
	Param (
		#Script parameters go here
		[Parameter(Mandatory=$false,Position=0,
		ValueFromPipeline=$true)]
		[string]$Path,
		
		[switch]$Force = $false
	)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# Main Script Execution:
	
	Begin {
		Write-LogInfo -LogPath $sLogFile -Message '<description of what is going on>...'
	}
	
	Process {
		Try {
			<code goes here>
		}
		
		Catch {
			Write-LogError -LogPath $sLogFile -Message $_.Exception -ExitGracefully
			Break
		}
	}
	
	End {
		If ($?) {
			Write-LogInfo -LogPath $sLogFile -Message 'Completed Successfully.'
			Write-LogInfo -LogPath $sLogFile -Message ' '
		}
		
		Return $Results
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
} # End Show-ExampleFunctionTemplate function --------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
function Start-PSAdmin {Start-Process PowerShell -Verb RunAs}
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
function Test-IsAdmin { #-----------------------------------------------------------------------------------------------
	([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
} #---------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function Get-FunctionName { #-------------------------------------------------------------------------------------------
	<#
	.NOTES
	Function name:
	$FunctionName = (Get-PSCallStack | Select-Object FunctionName -Skip 1 -First 1).FunctionName
	$FunctionName = (Get-Variable MyInvocation -Scope 1).Value.MyCommand.Name
	$FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
	.EXAMPLE
	$FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
	Write-Verbose "Running function: $FunctionName"
	.LINK
	https://stackoverflow.com/questions/3689543/is-there-a-way-to-retrieve-a-powershell-function-name-from-within-a-function#3690830
	#>
	$FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
	Write-Verbose "Running function: $FunctionName"
} # End Get-FunctionName function --------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function Get-ScriptPath { #---------------------------------------------------------------------------------------------
	<#
	.NOTES
	For PowerShell v3 and above.
	#>
	$PSCommandPath
} # End Get-ScriptPath function ----------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
function Get-ScriptDirectory { #----------------------------------------------------------------------------------------
  <#
  .SYNOPSIS
  Returns the path of the currently executing script.
  
  .DESCRIPTION
  
  .NOTES
  From:
  https://www.red-gate.com/simple-talk/dotnet/.net-tools/further-down-the-rabbit-hole-powershell-modules-and-encapsulation/
  
  To illustrate the difference between the two implementations, I created a test vehicle that evaluates the target expression in four different ways (bracketed terms are keys in the table that follows):
  
    - Inline code [inline]
    - Inline function, i.e. function in the main program [inline function]
    - Dot-sourced function, i.e. the same function moved to a separate .ps1 file [dot source]
    - Module function, i.e. the same function moved to a separate .psm1 file [module]
  
  The first two columns in the table define the scenario; the last two columns display the results of the two candidate implementations of Get-ScriptDirectory. A result of script means that the invocation correctly reported the location of the script. A result of module means the invocation reported the location of the module (see next section) containing the function rather than the script that called the function; this indicates a drawback of both implementations such that you cannot put this function in a module to find the location of the calling script. Setting this module issue aside, the remarkable observation from the table is that using the parent scope approach fails most of the time (in fact, twice as often as it succeeds)!
  
  ________________________________________________________________
  | Where Called | What Called     | Script Scope | Parent Scope |
  |--------------|-----------------|--------------|--------------|
  | Top Level    | inline          | script       | error**      |
  |              | inline function | script       | script       |
  |              | dot source      | script       | script       |
  |              | module*         | module*      | module*      |
  | Nested once  | inline          | script       | script       |
  |              | inline function | script       | error**      |
  |              | dot source      | script       | error**      |
  |              | module*         | module*      | module*      |
  | Nested twice | inline          | script       | error**      |
  |              | inline function | script       | error**      |
  |              | dot source      | script       | error**      |
  |              | module*         | module*      | module*      |
  ----------------------------------------------------------------
  
  (You can find my test vehicle code for this in my post on StackOverflow.)
  
  https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
  
  .LINK
  https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
  
  .LINK
  https://www.red-gate.com/simple-talk/dotnet/.net-tools/further-down-the-rabbit-hole-powershell-modules-and-encapsulation/
  #>
  Split-Path $script:MyInvocation.MyCommand.Path
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
function Get-ScriptDirectory2 { #---------------------------------------------------------------------------------------
	<#
	.LINK
	https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
	#>
	# For PowerShell 3.0 users - following works for both modules and script files:
	Split-Path -parent $PSCommandPath
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
function Get-ScriptDirectory3 { #https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
  <#
  .NOTES
  Thanks to Jeffrey Snover of the PowerShell team:
  https://www.red-gate.com/simple-talk/dotnet/.net-tools/further-down-the-rabbit-hole-powershell-modules-and-encapsulation/
  
  .EXAMPLE  
  Write-Host (Get-ScriptDirectory3)
  
  Will properly display the directory where your script resides rather than your current directory. 
  
  **Maybe.** The results you get from this function depend on where you call it from!
  
  See Get-ScriptDirectory1 and 
  https://www.red-gate.com/simple-talk/dotnet/.net-tools/further-down-the-rabbit-hole-powershell-modules-and-encapsulation/
  for more information.
  
  .LINK
  https://stackoverflow.com/questions/1183183/path-of-currently-executing-powershell-script#1183197
  
  .LINK
  https://www.red-gate.com/simple-talk/dotnet/.net-tools/further-down-the-rabbit-hole-powershell-modules-and-encapsulation/
  #>
  $Invocation = (Get-Variable MyInvocation -Scope 1).Value
  Split-Path $Invocation.MyCommand.Path
} # End Get-ScriptDirectory function -----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function Write-HorizontalRule { #---------------------------------------------------------------------------------------
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0)]
    [string]$HRtype = 'SingleLine'
  )
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd -eq $true) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
	# Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      Write-Host ===============================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host -------------------------------------------------------------------------------- # This too long
      Write-Host -------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  } ELSEIF ($LaunchedInCmd -eq $false) {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      Write-Host =======================================================================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host ------------------------------------------------------------------------------------------------------------------------ # This too long
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  }
} # End Write-HorizontalRule function ----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function Write-HorizontalRuleAdv { #------------------------------------------------------------------------------------
  <#
	.SYNOPSIS
	Writes a horizontal rule across the the console. 
	
	.DESCRIPTION
	Writes either a horzintal rule of different types:
	
	SingleLine "-------------------------" (default)
	DoubleLine "========================="
	DashedLine "- - - - - - - - - - - - -"
	BlankLine  "                         "
	
	Using different output types:
	
	using Write-Host (default):
	"-------------------------"
	
	using Write-Warning:
	"WARNING: ----------------"
	
	using Write-Verbose:
	"VERBOSE: ----------------"
	
	.PARAMETER HRtype
	Horizontal Rule types. Accepted types are 'SingleLine', 'DoubleLine', 'DashedLine', and 'BlankLine'. Defaults to 'SingleLine'.
	
	.PARAMETER SingleLine
	Set horizontal rule type as 'SingleLine'. Uses hyphen ('-'). If no other horizontal rule type is selected, will default to this.
	
	.PARAMETER DoubleLine
	Set horizontal rule type as 'DoubleLine'. Uses equals sign ('=')
	
	.PARAMETER DashedLine
	Set horizontal rule type as 'DashedLine'. Uses spaces between hyphen sign.
	
	.PARAMETER BlankLine
	Set horizontal rule type as 'BlankLine'
	
	.PARAMETER Endcaps
	Add a character to each end of the horizontal rule. Default is '#'. Set a different endcap character using -EndcapCharacter <single character>
	
	.PARAMETER EndcapCharacter
	Define which character is used as the end-cap using -EndcapCharacter "<SINGLE_CHARACTER>". Only works if the -Endcaps switch is also enabled. Default is '#'. 
	
	.PARAMETER IsWarning
	Prints the output as a warning (using Write-Warning).
	
	.PARAMETER IsVerbose
	Prints the output as a verbose message (using Write-Verbose). Will only be displayed if $VerbosePreference = "Continue"
	
	.EXAMPLE
	Write-HorizontalRuleAdv -BlankLine -Endcaps
	
	Prints a horizontal rule string like:
	"#                       #"
	
	.EXAMPLE
	Write-HR -double
	
	Uses the alias Write-HR to print a doubled horizontal rule (using the equals sign) like:
	"========================="
	
	.EXAMPLE
	Write-HR -dashed -IsWarning
	
	Uses the Write-HR alias to print a warning using Write-Warning, like:
	"WARNING:  - - - - - - - -"
	
	.EXAMPLE
	Write-HorizontalRuleAdv -HRtype SingleLine -Endcaps
	PS C:\> Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `|
	PS C:\> Write-HorizontalRuleAdv -HRtype DashedLine -Endcaps
	PS C:\> Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `|
	PS C:\> Write-HorizontalRuleAdv -HRtype DoubleLine -Endcaps
	
	Outputs something like:
	"#-----------------------#"
	"|                       |"
	"# - - - - - - - - - - - #"
	"|                       |"
	"#=======================#"
	
	.INPUTS
	If run without any input parameters, will default to a SingleLine "-----" ouput using Write-Host.
	
	.OUTPUTS
	Outputs a horizontal rule across the console of the selected type.
	
	.NOTES
	Command Prompt character width: 79
	PowerShell window character width: 119
	
	WARNING: 
	VERBOSE: 
	123456789
	
	.LINK
	about_Comment_Based_Help
	
	.LINK
	about_Functions_Advanced_Parameters
	
	.LINK
	https://docs.microsoft.com/en-us/powershell/developer/cmdlet/validating-parameter-input
	
	.LINK
	https://social.technet.microsoft.com/wiki/contents/articles/15994.powershell-advanced-function-parameter-attributes.aspx
	
	.LINK
	help about_Automatic_Variables
	
	.LINK
	help about_If
	
	.LINK
	help about_Comparison_Operators
	
  #>
  
  #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  [CmdletBinding(
    DefaultParameterSetName='DefineString'
  )]
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0,
    ParameterSetName='DefineString')]
    [ValidateSet("SingleLine", "DoubleLine", "DashedLine", "BlankLine")]
    [Alias('HorizontalRule','HorizontalRuleType','Type','hr')]
    [string]$HRtype = 'SingleLine',
    
    [Parameter(ParameterSetName='SingleLine')]
    [Alias('s','single')]
    [switch]$SingleLine,
    
    [Parameter(ParameterSetName='DoubleLine')]
    [Alias('d','dbl','double')]
    [switch]$DoubleLine,
    
    [Parameter(ParameterSetName='DashedLine')]
    [Alias('dash','dashed')]
    [switch]$DashedLine,
    
    [Parameter(ParameterSetName='BlankLine')]
    [Alias('blank')]
    [switch]$BlankLine,
    
    [Parameter(Mandatory=$false)]
    [switch]$Endcaps = $false,

    [Parameter(Mandatory=$false)]
    [string]$EndcapCharacter = '#',
    
    [Parameter(Mandatory=$false)]
    [switch]$IsWarning = $false,

    [Parameter(Mandatory=$false)]
    [switch]$IsVerbose = $false,

    [Parameter(Mandatory=$false)]
    [switch]$MaxLineLength = $false
  )
  
  #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  # Function name:
  # https://stackoverflow.com/questions/3689543/is-there-a-way-to-retrieve-a-powershell-function-name-from-within-a-function#3690830
  #$FunctionName = (Get-PSCallStack | Select-Object FunctionName -Skip 1 -First 1).FunctionName
  #$FunctionName = (Get-Variable MyInvocation -Scope 1).Value.MyCommand.Name
  $FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
  
  # Set $HRtype
  If ($SingleLine) {
    $HRtype = "SingleLine"
  } elseif ($DoubleLine) {
    $HRtype = "DoubleLine"
  } elseif ($DashedLine) {
    $HRtype = "DashedLine"
  } elseif ($BlankLine) {
    $HRtype = "BlankLine"
  }
  
  # Detect if $LaunchedInCmd
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
    # Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "==============================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                               "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "--------------------------------------------------------------------------------" # This too long
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  } ELSE {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "======================================================================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                                                                       "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "------------------------------------------------------------------------------------------------------------------------" # This too long
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  }
  
  # Command Prompt character width: 79
  # PowerShell window character width: 119
  $MaxLength = $HRoutput.Length
  
  IF ($IsWarning -eq $true -or $IsVerbose -eq $true) {
    #WARNING: 
    #VERBOSE: 
    #123456789
    $MaxLength = $MaxLength - 9
    $HRoutput = ($HRoutput).Substring(9,$MaxLength)
  }
  
  IF ($Endcaps -eq $true) {
    #$EndcapLength = $MaxLength - 2
    $MaxLength = $MaxLength - 2
    #$HRoutput = ($HRoutput).Substring(1,$EndcapLength)
    $HRoutput = ($HRoutput).Substring(1,$MaxLength)
    $HRoutput = "$EndcapCharacter$HRoutput$EndcapCharacter"
  }
  
  $MaxLineLengthOutput = $MaxLength
  
  # Write output
  
  IF ($MaxLineLength -eq $true) {
    Write-Output $MaxLineLengthOutput
  } ELSEIF ($IsWarning -eq $true) {
    Write-Warning $HRoutput -WarningAction Continue
  } ELSEIF ($IsVerbose -eq $true) {
    # Set Verbose message display
	#$VerbosePreference = "SilentlyContinue" # Will suppress Write-Verbose messages. This is the default value.
	#$VerbosePreference = "Continue" # Will print out Write-Verbose messages. Gets set when -Verbose switch is used to run the script. (Or when you set the variable manually.)
    #$OrigVerbosePreference = $VerbosePreference
    #$VerbosePreference = "Continue" # Print out Write-Verbose messages.
    Write-Verbose $HRoutput
    #$VerbosePreference = $OrigVerbosePreference
  } ELSE {
    Write-Host $HRoutput
  }
  
  #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
} # End Write-HorizontalRuleAdv function -------------------------------------------------------------------------------
Set-Alias -Name "Write-HR" -Value "Write-HorizontalRuleAdv" # -Scope Global
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function PromptForChoice-YesNoSectionSkip { #---------------------------------------------------------------------------
	
	Param (
		#Script parameters go here
		[Parameter(Mandatory=$false,Position=0,
		ValueFromPipeline = $true)]
		[string]$SectionName
	)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Build Choice Prompt
	#-----------------------------------------------------------------------------------------------------------------------
	$Title = "Skip this section?"
	$Info = "$SectionName"
	$ChoiceYes = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "[Y]es, skip this section."
	$ChoiceNo = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "[N]o, do not skip this section"
	$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceYes, $ChoiceNo)
	# default choice: 0 = first Option, 1 = second option, etc.
	[int]$defaultchoice = 0
	#-----------------------------------------------------------------------------------------------------------------------
	# Execute Choice Prompt
	#-----------------------------------------------------------------------------------------------------------------------
	# PromptForChoice() output will always be integer: https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
	If ($SectionName) {
		$answer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
	} else {
		$answer = $host.UI.PromptForChoice($Title, "", $Options, $defaultchoice)
	}
	#-----------------------------------------------------------------------------------------------------------------------
	# Interpret answer
	#-----------------------------------------------------------------------------------------------------------------------
	#help about_switch
	#https://powershellexplained.com/2018-01-12-Powershell-switch-statement/#switch-statement
	#Write-Verbose "Answer = $answer"
	switch ($answer) {
		0 { # Y - Yes
			Write-Verbose "Yes ('$answer') option selected."
			$ChoiceSkipSection = 'Y'
		}
		1 { # N - No
			Write-Verbose "No ('$answer') option selected."
			$ChoiceSkipSection = 'N'
		}
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Return $ChoiceSkipSection

} # End PromptForChoice-YesNoSectionSkip function ----------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
Function PromptForChoice-YesNo { #--------------------------------------------------------------------------------------
	
	Param (
		#Script parameters go here
		[Parameter(Mandatory=$true,Position=0,
		ValueFromPipeline = $true)]
		[string]$TitleName,
		
		[Parameter(Mandatory=$false)]
		[string]$InfoDescription,
		
		[Parameter(Mandatory=$false)]
		[string]$HintPhrase
	)
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	#-----------------------------------------------------------------------------------------------------------------------
	# Build Choice Prompt
	#-----------------------------------------------------------------------------------------------------------------------
	$Title = "$TitleName?"
	$Info = "$InfoDescription"
	$ChoiceYes = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "[Y]es, $HintPhrase."
	$ChoiceNo = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "[N]o, do not $HintPhrase."
	$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceYes, $ChoiceNo)
	# default choice: 0 = first Option, 1 = second option, etc.
	[int]$defaultchoice = 0
	#-----------------------------------------------------------------------------------------------------------------------
	# Execute Choice Prompt
	#-----------------------------------------------------------------------------------------------------------------------
	# PromptForChoice() output will always be integer: https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
	If ($InfoDescription) {
		$answer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
	} else {
		$answer = $host.UI.PromptForChoice($Title, "", $Options, $defaultchoice)
	}
	#-----------------------------------------------------------------------------------------------------------------------
	# Interpret answer
	#-----------------------------------------------------------------------------------------------------------------------
	#help about_switch
	#https://powershellexplained.com/2018-01-12-Powershell-switch-statement/#switch-statement
	#Write-Verbose "Answer = $answer"
	switch ($answer) {
		0 { # Y - Yes
			Write-Verbose "Yes ('$answer') option selected."
			$ChoiceResultVar = 'Y'
		}
		1 { # N - No
			Write-Verbose "No ('$answer') option selected."
			$ChoiceResultVar = 'N'
		}
	}
	
	#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	Return $ChoiceResultVar

} # End PromptForChoice-YesNo function ---------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Once [Functions] block has finished running, exit the script if -LoadFunctions switch is on.
If ($LoadFunctions) {
  #https://stackoverflow.com/questions/2022326/terminating-a-script-in-powershell
  # Only load functions of script. Do not execute Main script block.
  Return
}
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Execution]------------------------------------------------------

#=======================================================================================================================
#Index:
#1. Test different methods of writing output
#2. Testing Write-HorizontalRule function
#3. Testing Convert-AMPMhourTo24hour
#5. Testing Out-GridView
#6. User Choice Selection / Menu Demos
#7. Test For loop & date formatting
#8. Test multi-dimensional variable methods
#9. Test running external script
#=======================================================================================================================

#-----------------------------------------------------------------------------------------------------------------------
#=======================================================================================================================
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#
#
##Script MAIN Execution goes here
PAUSE
Clear-Host # CLS
Start-Sleep -Milliseconds 100 #Bugfix: Clear-Host acts so quickly, sometimes it won't actually wipe the terminal properly. If you force it to wait, then after PowerShell will display any specially-formatted text properly.
Write-Verbose `n
Write-HorizontalRuleAdv -HRtype DoubleLine -IsVerbose
Write-Verbose `n
Write-Verbose "Script Main beginning. $ScriptName"

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#1. Test different methods of writing output
#=======================================================================================================================

$SectionName = "#1. Test different methods of writing output"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# run "help about_comment_based_help" - I want to display formatted help for a function or script. Use comment-based help instead - run "help about_comment_based_help". PowerShell will format it for you.
# https://technet.microsoft.com/en-us/library/dd819489.aspx
# Write-Host - You almost never need to do it. 
# Write-Information - Only works if $ErrorActionPreference = 'Continue' Does not work if = 'SilentlyContinue' Prints grey text. Can be overridden with -InformationAction Continue
# Write-Verbose - Writes yellow VERBOSE: messages (9 chars). Can be turned on/off by running script with -Verbose parameter.
# Write-Debug - Pauses script execution every time it's called. Can be turned on/off by running script with -Debug parameter.
# Write-Warning - Writes yellow WARNING: messages (9 chars), regardless of -Verbose or -Debug switches.
# Write-Error - Only works if $ErrorActionPreference = 'Continue' Does not work if = 'SilentlyContinue' Prints in red text, "Entire Script path: Error message." E.g. C:\Users\G\Documents\SpiderOak Hive\Consulting\2018-04-06 SodaLakeNetworking\Manage-SodaLakeData.ps1 : TEST ERROR.
# Write-Output - I just need to display some text! Do you really? PowerShell works better with objects, and that's what your script should be outputting, by means of Write-Output. Let PowerShell's Format cmdlets turn those objects into text like lists and tables.
# Write-Progress - Makes a green and yellow progress bar appear at the top part of the command window.

Write-Host "Script Main beginning." $MyInvocation.MyCommand.Name
Write-Information -MessageData "Will only display if set defaults display infromational messages."
Write-Information -MessageData "Test informational messages." -InformationAction Continue
Write-Verbose "Script body."
Write-Verbose "Debug preference = $DebugPreference"
Write-Debug "Script Main beginning." # NOTE: Writing debug text will PAUSE script execution automatically.
Write-Warning "Test Warning."
Write-Error -Message "TEST ERROR. TEST ERROR. TEST ERROR. TEST ERROR." -Category InvalidData -ErrorId TEST_ID
For ($I = 1; $I -le 100; $I++) {Write-Progress -Activity "Test in progress..." -Status "$I% Complete:" -PercentComplete $I;}
#For ($I = 1; $I -le 1000; $I++) {Write-Progress -Activity "Test in progress..." -Status "$($I / 10)% Complete:" -PercentComplete ($I/10)}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#2. Test different methods of writing output thru Logging Module
#-----------------------------------------------------------------------------------------------------------------------

# Write-LogInfo ? Writes an informational message to the log file
# Write-LogWarning ? Writes a warning message to the log file (with the format of WARNING: )
# Write-LogError ? Writes an error message to the log file (with the format of ERROR: ). In addition, optionally calls Stop-Log to end logging and terminate the calling script on fatal error.

Write-LogInfo -LogPath $sLogFile -Message "-----------------------------------------------------------------------------------------------------------------------"
Write-LogInfo -LogPath $sLogFile -Message "[TIMESTAMP]: $($Time)"

Write-LogInfo -LogPath $sLogFile -Message "Test log info write."
Write-LogWarning -LogPath $sLogFile -Message "Test log warning write."
Write-LogError -LogPath $sLogFile -Message "Test log error write."

#Read-Host "Press ENTER key to continue . . . " # PAUSE (Read-Host automatically adds colon : at the end of prompt)
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#2. Test Write-Host colors output
#-----------------------------------------------------------------------------------------------------------------------

<#
help Write-Host -Full

-BackgroundColor <ConsoleColor>

- Black
- DarkBlue
- DarkGreen
- DarkCyan
- DarkRed
- DarkMagenta
- DarkYellow
- Gray
- DarkGray
- Blue
- Green
- Cyan
- Red
- Magenta
- Yellow
- White

-ForegroundColor <ConsoleColor>

- Black
- DarkBlue
- DarkGreen
- DarkCyan
- DarkRed
- DarkMagenta
- DarkYellow
- Gray
- DarkGray
- Blue
- Green
- Cyan
- Red
- Magenta
- Yellow
- White
#>

$TestText = "The quick brown fox jumped over the lazy dog."

Write-Verbose `n
Write-HorizontalRuleAdv -HRtype SingleLine

Write-Host $TestText -ForegroundColor White -BackgroundColor Black
Write-Host $TestText -ForegroundColor Yellow -BackgroundColor Black
Write-Host $TestText -ForegroundColor Magenta -BackgroundColor Black
Write-Host $TestText -ForegroundColor Red -BackgroundColor Black
Write-Host $TestText -ForegroundColor Cyan -BackgroundColor Black
Write-Host $TestText -ForegroundColor Green -BackgroundColor Black
Write-Host $TestText -ForegroundColor Blue -BackgroundColor DarkRed
Write-Host $TestText -ForegroundColor DarkGray -BackgroundColor Cyan
Write-Host $TestText -ForegroundColor Gray -BackgroundColor Black
Write-Host $TestText -ForegroundColor DarkYellow -BackgroundColor Black
Write-Host $TestText -ForegroundColor DarkMagenta -BackgroundColor White
Write-Host $TestText -ForegroundColor DarkRed -BackgroundColor Black
Write-Host $TestText -ForegroundColor DarkCyan -BackgroundColor Red
Write-Host $TestText -ForegroundColor DarkGreen -BackgroundColor Black
Write-Host $TestText -ForegroundColor DarkBlue -BackgroundColor DarkMagenta
Write-Host $TestText -ForegroundColor Black -BackgroundColor White

Write-HorizontalRuleAdv -HRtype SingleLine

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#2. Testing Write-HorizontalRule function
#=======================================================================================================================

$SectionName = "#2. Testing Write-HorizontalRule function"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host "Write-HorizontalRule Help output:"
Write-HorizontalRule
Get-Help Write-HorizontalRule
Get-Help Write-HorizontalRule -Full
Write-HorizontalRule
Write-Verbose "Script MAIN execution. $ScriptName"
Write-Host "Script MAIN execution." $MyInvocation.MyCommand.Name
Write-HorizontalRule -HRtype DoubleLine
Write-HorizontalRule -HRtype DashedLine
Write-HorizontalRule -HRtype SingleLine
Write-HorizontalRule -HRtype IntentionallyThrowError -Verbose

Write-Host `n
Write-Host "Write-HorizontalRuleAdv Help output:"
Write-HorizontalRule
Get-Help Write-HorizontalRuleAdv -Full
Write-HorizontalRule

Write-HorizontalRuleAdv -HRtype SingleLine -Verbose
Write-HorizontalRuleAdv -HRtype DashedLine -Verbose
Write-HorizontalRuleAdv -HRtype DoubleLine -Verbose
Write-HorizontalRuleAdv -HRtype SingleLine -Endcaps
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `|
Write-HorizontalRuleAdv -HRtype DashedLine -Endcaps
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `|
Write-HorizontalRuleAdv -HRtype DoubleLine -Endcaps

Write-HorizontalRuleAdv -HRtype SingleLine -IsVerbose
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
Write-HorizontalRuleAdv -HRtype DoubleLine -IsVerbose
Write-HorizontalRuleAdv -HRtype SingleLine -Endcaps -IsVerbose
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsVerbose
Write-HorizontalRuleAdv -HRtype DashedLine -Endcaps -IsVerbose
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsVerbose
Write-HorizontalRuleAdv -HRtype DoubleLine -Endcaps -IsVerbose

Write-HorizontalRuleAdv -HRtype SingleLine -IsWarning
Write-HorizontalRuleAdv -HRtype DashedLine -IsWarning
Write-HorizontalRuleAdv -HRtype DoubleLine -IsWarning
Write-HorizontalRuleAdv -HRtype SingleLine -Endcaps -IsWarning
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsWarning
Write-HorizontalRuleAdv -HRtype DashedLine -Endcaps -IsWarning
Write-HorizontalRuleAdv -HRtype BlankLine -Endcaps -EndcapCharacter `| -IsWarning
Write-HorizontalRuleAdv -HRtype DoubleLine -Endcaps -IsWarning

PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#3. Testing Convert-AMPMhourTo24hour
#=======================================================================================================================

$SectionName = "#3. Testing Convert-AMPMhourTo24hour"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

<#
12.1
11.6
11.4
11
011
9.6
9.4
09
9
-9
.9
0.9
.0
0.0
#>

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

help Convert-AMPMhourTo24hour

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host "help Convert-AMPMhourTo24hour -full"
Write-Warning "Executing `"help Convert-AMPMhourTo24hour -full`" from a script environment during run will not display any of the extra information from the -Full switch. The command must be executed from the command line to get entire help content."

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 0 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 1 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 12 -AM


Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 09.6 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 09.4 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 12.1 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 11.6 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 11.4 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 11 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 011 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 9.6 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 9.4 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 009 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 09 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour -9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour .9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 0.9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour .0 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 0.0 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host `r`n

Write-Host "Example #1:"

$AMPMhour = 4

$OutputVar = Convert-AMPMhourTo24hour $AMPMhour -PM

Write-Host "$AMPMhour PM = $OutputVar           (24-hour)"

Write-Host `r`n

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host `r`n

Write-Host "Example #2:"

Get-Date -UFormat %I | Convert-AMPMhourTo24hour -PM

$NowHour = Get-Date -UFormat %I
Write-Host "`$NowHour = $NowHour"

$OutputVar = (Get-Date -UFormat %I | Convert-AMPMhourTo24hour -PM)
Write-Host "`$OutputVar = $OutputVar"

Write-Host "$NowHour PM = $OutputVar           (24-hour)"
Write-Host "$(Get-Date -UFormat %I) PM = $OutputVar           (24-hour)"

Write-Host `r`n

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host `r`n

Write-Host "Example #3:"

Get-Random -Minimum 1 -Maximum 12 | Convert-AMPMhourTo24hour -PM

Get-Random -Minimum 1 -Maximum 12 | Tee-Object -Variable Randomvar | Convert-AMPMhourTo24hour -PM
Write-Host "`$Randomvar = $Randomvar"

$OutputVar = (Get-Random -Minimum 1 -Maximum 12 | Tee-Object -Variable Randomvar | Convert-AMPMhourTo24hour -PM)
Write-Host "$Randomvar PM = $OutputVar           (24-hour)"

Write-Host `r`n

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#5. Testing Out-GridView
#=======================================================================================================================

$SectionName = "#5. Testing Out-GridView"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#https://mcpmag.com/articles/2016/02/17/creating-a-gui-using-out-gridview.aspx
Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "A quick way to go back in your history and run the same command again:"
Write-Host "Get-History | Out-GridView -PassThru | Invoke-Expression"
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
Get-History | Out-GridView -PassThru | Invoke-Expression

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Looking at the cmdlet help:"
Get-Command | Out-GridView -PassThru | Get-Help -ShowWindow 

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Looking at the about* Help Files:"
Get-Help about* | Out-GridView -PassThru | Get-Help -ShowWindow 

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Menu example using Out-GridView:"
$Menu = [ordered]@{
	1 = 'Do something'
	2 = 'Do this instead'
	3 = 'Do whatever you want'
}

$Result = $Menu | Out-GridView -PassThru -Title 'Make a selection'

Switch ($Result) {
	{$Result.Name -eq 1} {Write-Host 'Do something'}
	{$Result.Name -eq 2} {Write-Host 'Do this instead'}
	{$Result.Name -eq 3} {Write-Host 'Do whatever you want'}   
} 

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Advanced Out-GridView usage:"
$WMI =  @{
	Filter =  "DriveType='3' AND (Not Name LIKE  '\\\\?\\%')"
	Class =  "Win32_Volume"
	ErrorAction =  "Stop"
	Property =  "Name","Label","Capacity","FreeSpace"
	Computername =  $Env:COMPUTERNAME
}

$List = New-Object System.Collections.ArrayList

Get-WmiObject @WMI  | ForEach {

	$Decimal  = $_.freespace / $_.capacity

	$Graph  = "$($Bar)"*($Decimal*100)

	$Hash = [ordered]@{

		Computername =  $Env:COMPUTERNAME

		Name =  $_.Name

		FreeSpace =  "$Graph"       

		Percent =  $Decimal

		FreeSpaceGB =  ([math]::Round(($_.Freespace/1GB),2))

		CapacityGB =  ([math]::Round(($_.Capacity/1GB),2))

	}

	[void]$List.Add((

		[pscustomobject]$Hash

	))

}

$List | Out-GridView -Title 'Drive Space' 

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#6. User Choice Selection / Menu Demos
#=======================================================================================================================

$SectionName = "#6. User Choice Selection / Menu Demos"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------

Write-Host `r`n
Write-Host "User Choice Selection / Menu Demos"
Write-Host `r`n

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host 'Method #1: "Read-Host -Prompt"'
Write-HorizontalRuleAdv -HRtype DashedLine
do {
	$ChoiceYesNoCancel = Read-Host -Prompt "[Y]es, [N]o, or [C]ancel? [Y\N\C]"
	switch ($ChoiceYesNoCancel) {
		'Y'	{ # Y - Yes
			Write-Verbose "Yes ('$ChoiceYesNoCancel') option selected."
			Write-Host "Yes ('$ChoiceYesNoCancel') option selected."
			Write-Host `r`n
		}
		'N' { # N - No
			Write-Verbose "No ('$ChoiceYesNoCancel') option selected."
			Write-Host "No ('$ChoiceYesNoCancel') option selected."
			Write-Host `r`n
		}
		'C' { # C - Cancel
			Write-Verbose "Cancel ('$ChoiceYesNoCancel') option selected."
			Write-Host "Cancel ('$ChoiceYesNoCancel') option selected."
			Write-Host `r`n
		}
		default { # Choice not recognized.
			Write-Host `r`n
			Write-Host "Choice `"$ChoiceYesNoCancel`" not recognized. Options must be Yes, No, or Cancel."
			#Write-HorizontalRuleAdv -HRtype DashedLine
			Write-Host `r`n
			#Break #help about_Break
			PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
			Write-Host `r`n
			Write-HorizontalRuleAdv -HRtype DashedLine
		}
	}
}
until ($ChoiceYesNoCancel -eq 'Y' -Or $ChoiceYesNoCancel -eq 'N' -Or $ChoiceYesNoCancel -eq 'C')
Write-HorizontalRuleAdv -HRtype DashedLine
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `r`n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host 'Method #2: "PromptForChoice()"'
#-----------------------------------------------------------------------------------------------------------------------
# Build Menu
#-----------------------------------------------------------------------------------------------------------------------
#Clear-Host # CLS
#Start-Sleep -Milliseconds 100 #Bugfix: Clear-Host acts so quickly, sometimes it won't actually wipe the terminal properly. If you force it to wait, then after PowerShell will display any specially-formatted text properly.
Write-HorizontalRuleAdv -HRtype DashedLine
#-----------------------------------------------------------------------------------------------------------------------
# Build Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
$Title = "Main Menu"
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
$Info = 'User choice selection example using "PromptForChoice()"'
$Info = @"
User choice selection example using "PromptForChoice()"

Y - Yes
N - No
Q - Quit
 
Select a choice:
"@
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# &Quit makes Q a Hot Key. 
$ChoiceYes = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "Select [Y]es as the answer."
$ChoiceNo = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "Select [N]o as the answer."
$ChoiceQuit = New-Object System.Management.Automation.Host.ChoiceDescription "&Quit", "[Q]uit, prints `"Good Bye!!!`" in green"
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceYes, $ChoiceNo)
# default choice: 0 = first Option, 1 = second option, etc.
[int]$defaultchoice = 1
#-----------------------------------------------------------------------------------------------------------------------
# Execute Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
# PromptForChoice() output will always be integer: https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
# If run from shell, will create a GUI dialog box. If run from script, will create choice text menu in command line.
# https://social.technet.microsoft.com/wiki/contents/articles/24030.powershell-demo-prompt-for-choice.aspx
$answer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
#-----------------------------------------------------------------------------------------------------------------------
# Interpret answer
#-----------------------------------------------------------------------------------------------------------------------
#help about_switch
#https://powershellexplained.com/2018-01-12-Powershell-switch-statement/#switch-statement
Write-Verbose "Answer = $answer"
switch ($answer) {
	0	{ # Y - Yes
		Write-Verbose "Yes ('$answer') option selected."
		Write-Host "Si Senor." -ForegroundColor Green
		Write-Host `r`n
	}
	1 { # N - No
		Write-Verbose "No ('$answer') option selected."
		Write-Host "No gracias." -ForegroundColor Orange
		Write-Host `r`n
	}
	2 {
		Write-Verbose "Quit ('$answer') option selected."
		Write-Host "Good Bye!!!" -ForegroundColor Green
		Write-HorizontalRuleAdv -HRtype DashedLine
		Write-Host `r`n
	}
}
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `r`n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host 'Method #3: "Out-GridView -PassThru"'
Write-HorizontalRuleAdv -HRtype DashedLine
#-----------------------------------------------------------------------------------------------------------------------
# Build Menu
#-----------------------------------------------------------------------------------------------------------------------
Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Menu example using Out-GridView:"
#-----------------------------------------------------------------------------------------------------------------------
# Build Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
$Title = "Main Menu"
$Menu = [ordered]@{
	1 = 'Yes'
	2 = 'No'
	3 = 'Cancel'
}
#-----------------------------------------------------------------------------------------------------------------------
# Execute Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
# Using Out-GridView creates a GUI selection window with filter ability
# and ability to select multiple options with the -PassThru switch
$Result = $Menu | Out-GridView -PassThru -Title $Title
#-----------------------------------------------------------------------------------------------------------------------
# Interpret answer
#-----------------------------------------------------------------------------------------------------------------------
$answer = $Result.Name
Write-Verbose "`$Result.Name = $answer"
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
Switch ($answer) {
	1 {
		Write-Host '"Yes" was selected.'
	}
	2 {
		Write-Host '"No" was selected.'
	}
	3 {
		Write-Host '"Cancel" was selected.'
	}
}
Write-HorizontalRuleAdv -HRtype DashedLine
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#7. Test For loop & date formatting
#=======================================================================================================================

$SectionName = "#7. Test For loop & date formatting"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Months in 3 letters."
# https://www.business.com/articles/powershell-for-loop/
# help about_For
For ($m=1; $m -lt 13; $m++) {
	$m
	Get-Date -Month $m -UFormat %b
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#8. Test multi-dimensional variable methods
#=======================================================================================================================

$SectionName = "#8. Test multi-dimensional variable methods"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 1."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test1.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($column in $CSVarray) {
	Write-Host "Start of loop."
	Write-Host "Whole:     $column"
	Write-Host "Array One: $column[0]"
	Write-Host "Array Two: $column[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 2."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test2.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($line in $CSVarray) {
	Write-Host "Start of loop."
	Write-Host "Whole:     $line"
	Write-Host "Array One: $line[0]"
	Write-Host "Array Two: $line[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 3."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test3.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($line in $CSVarray) {
	Write-Host "Start of loop."
	Write-Host "Whole:     $line"
	Write-Host "Array One: $line[0]"
	Write-Host "Array Two: $line[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host `n
Write-Host "Test Import-CSV ForEach loop."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test3.csv"
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
$CSVimport = Import-CSV $CSVfile -Delimiter "," -Header $CSVheaders
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
Import-CSV -Path $CSVfile -Delimiter "," -Header $CSVheaders | ForEach {
	Write-Host "Start of loop."
	Write-Host "Whole:     $_"
	Write-Host "Array One: $_[0]"
	Write-Host "Array Two: $_[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host `n
Write-Host "Test Import-CSV ForEach loop 2."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test4.csv"
$CSVheaders = "col1,col2,col3"
$CSVarray = (Get-Content $CSVfile).split(",")
$CSVimport = Import-CSV -Path $CSVfile -Delimiter "," -Header $CSVheaders
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
Import-CSV -Path $CSVfile | ForEach {
	Write-Host "Start of loop."
	Write-Host "Whole:     $_"
	Write-Host "Col call: $($_."header 1")"
	Write-Host "Col call: $($_."header 2")"
	Write-Host "Col call: $($_.H1)"
	Write-Host "Col call: $($_."header 4")"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DoubleLine
Write-Host `n
Write-Host "Perform actions from a CSV file."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\commands.csv"
$CSVheaders = "Program,Exec Command"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
# The foreach alias also supports beginning command blocks, middle command blocks, and end command blocks. The beginning and end command blocks run once, and the middle command block runs every time the Foreach loop steps through a collection or array.
# <command> | foreach {<beginning command_block>}{<middle command_block>}{<ending command_block>}
Import-CSV -Path $CSVfile | ForEach-Object {
	# beginning (runs once)
	Write-Host `n
	Write-Host "Beginning block: ForEach"
	Write-Host `n
}{
	# middle (loop)
	Write-Host "$_"
	
	# https://discoposse.com/2012/01/23/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-1/
	# https://discoposse.com/2012/01/23/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-2/
	# https://discoposse.com/2012/12/29/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-3/
	
	$HostProgram = $_.Program
	$CommandToExecute = $_."Exec Command"
	
	Write-Host "Host Program: $HostProgram"
	Write-Host "Expand Var: $($_.Program)"
	
	Write-Host "Command to execute: $CommandToExecute"
	Write-Host "Expand Var: $($_."Exec Command")"
	Write-Host `n
}{
	# ending (runs once)
	Write-Host "Ending block: ForEach"
	Write-Host `n
}

Write-Host "Loop is over."
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#9. Test running external script
#=======================================================================================================================

$SectionName = "#9. Test running external script"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Run External Script."
$ExternalScript = "$Home\Documents\SodaLake\PowerShell\Choice\DialogDemo.ps1"
PowerShell.exe -NoProfile -ExecutionPolicy Bypass -Command "& '$ExternalScript'"
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-Verbose "/Script body."
Write-HorizontalRuleAdv -HRtype DoubleLine
#Script MAIN Execution ends here
#
#
#
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#=======================================================================================================================
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Footer]---------------------------------------------------------

Write-Host `n
Write-Host "End of script" $MyInvocation.MyCommand.Name
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
Write-Host `n

Write-Verbose "Script Main end. $ScriptName"
Write-Debug "End-of-script. $ScriptName"
Write-LogInfo -LogPath $sLogFile -Message "End of script $ScriptName"
Stop-Log -LogPath $sLogFile
Write-Output $sLogFile
Return
